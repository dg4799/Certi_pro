"""
배열의 전체에서 반씩 쪼개가며 레벨을 만들다보면 트리 형태의 구조가 나옴

                                                          0 ~ 14(1)                                                            --> 시작위치 인덱스가 2의 0승 = 1
                         0~7(2)                                                             8~14(3)                            --> 시작위치 인덱스가 2의 1승 = 2
Segment           0~3(4)                     4~7(5)                         8~11(6)                      12~14(7)              --> 시작위치 인덱스가 2의 2승 = 4
Tree       0~1(8)       2~3(9)          4~5(10)      6~7(11)         8~9(12)        10~11(13)      12~13(14)     14(15)        --> 시작위치 인덱스가 2의 3승 = 8
         0(16) 1(17)  2(18) 3(19)    4(20) 5(21)   6(22) 7(23)     8(24) 9(25)   10(26) 11(27)   12(28) 13(29)                 --> 시작위치 인덱스가 2의 4승 = 16
list     1     3      11    6        7     10      14    9         18    16      5      4         2      8       19

- 여기서 index 5의 값을 13으로 바꾼다면
  index 5인 10부터 10이 속한 상위 레벨의 Segment에 값의 차이만큼 다 반영해줌.

- Segment Tree의  root(최상단) 부터 차례대로 1부터 시작하는 번호(segment index)를 부여함
  complete tree의 특성을 가짐 : 트리를 모두 채워 맨 마지막 레이어를 제외하면 모든 인덱스가 채워지는 특성

- 트리는 최상단부터 반(2개씩) 나뉘어 지기 때문에 2의 n승의 형태로 시작 index가 늘어남

- 부모에서 자식으로 내려가는 경우  / 자식에서 부모로 올라가는 경우
        i                              i/2  j/2
   i*2     i*2+1                    i            j

- Segment Tree : 각 레벨의 노드의 값을 인덱스에 저장
  [0(안씀), 1, 2, 3, 4, .... 29]

"""