⬜ sqrt 구간합
  - 숫자들의 갯수가 320개라면 0~320개가 모두 더해져서 제곱근 리스트 0번(숫자들을 제곱근으로 나눈 몫)
    1. left가 다음 구간까지 도달 할때까지 계속 더함
      - while left <= right (320보다 작을경우 right까지만 더함) and left%제곱근 (나누어졌을때 몫이 0이되어 구간에 도달한 것임. 0 = false로 탈출)
            left += 1 (제곱근에 도달할때까지 +)
            res += 숫자
    2. right가 전 구간까지 도달 할떄까지 계속 더함
      - while left <= right (320보다 작을경우 left까지만 더함) and right+1%제곱근 (여기서 right+1은 321까지 더하는 것임)
            right -=1
            res += 숫자
    3. left와 right 사이 구간의 합을 더함
      - while left <= right (left에 +제곱근을 하는데 right를 초과하면 구간이 넘어가므로 탈출)
            res += sqrt_time[left//sqrt] (left가 320이고 320으로 나눈 몫은 1임, 1번 구간에 대한 덧셈이 이루어짐)
            left += sqrt (left에 제곱근을 더해 다음 구간을 계산)
    ★ 미리 합산된 구간합을 이용해서 빠르게 구간합을 구할 수 있음!

⬜ sqrt 2차원 구간합 또는 구간체크
  - X, Y를 특정 값으로 나눠 구간을 형성 (ex) l값 이상이 이상치인경우 특정구간을 l로 형성)
  - l로 나눈 구간을 nX, nY로 정하고 해당 구간에 대해 hash를 만들어 데이터들을 관리 ex) hash[(nX, nY)].append(mX, mY, mID, ..)
  - pX, pY 부터 특정지점까지 거리를 구할때 pX, pY가 속한 구간을 구해서 그 구간에 dx = [0, 1, -1], dy = [0, 1, -1]을 이중 for문으로 돌리면
   ★ pX, pY가 속한 구간에서 주변 모든 구간에 해당되는 지점의 데이터만 체크가능!

⬜ Dijkstra
  - 지점과 지점들간의 거리 또는 비용을 알고 있을때
     ex) hash[mid]=(next_mid, dist)
         hash[next_mid]=(mid, dist)
  - 지점 갯수만큼 무한배열[INF, INF..]을 만든다 --> 인덱스 번호가 지점이고 인덱스의 값이 비용임
  - start 인덱스의 비용을 0으로 잡고(무한배열[0] = 0) q에 넣고 while 시작(heappush(q, (0, start))
  - q에서 값을 빼내어(dist, now = heappop(q)) hash[now]에서 값을 빼옴 (next_mid, dist)
  - start dist + next_mid dist = cost가 됨
  - cost가 무한배열[next_mid]보다 낮으면(더 저렴하게 이동이 가능하면) --> 무한배열[next_mid]를 cost로 갱신
  - 다시 q에 현재의 cost와 next_mid를 넣는다 --> heappush(q, (cost, next_mid))
  - 그럼 next_mid와 연결되어 있는 mid를 hash[next_mid]를 통해 찾아 들어가서 비용갱신을 반복해서
    연결되어있는 지점들은 cost가 갱신되고 연결이 안되어있는 지점들은 INF 갚으로 남아서
    ★ 연결되어 있는 지점에 대한 최소 비용을 구할 수 있음!

⬜ LCA (최소 공통 조상)
  ★ 노드의 이름에 인덱스 번호를 부여!!! 부모리스트와 깊이리스트를 해당 인덱스에 값을 넣고 꺼내쓴다!
  - 노드를 입력받으면 인덱스 번호를 부여하고 리스트에 저장 --> info_name[노드이름] = 인덱스번호
  - 입력받은 부모의 이름으로 부모 인덱스번호를 찾음 --> parent_idx = info_name[부모 노드 이름]
  - 부모 리스트에 부모 인덱스번호를 추가한다 --> parent_list.append(부모 인덱스번호) --> 해당 인덱스에 부모인덱스 번호가 기록됨
  - 깊이 리스트에 부모 인덱스번호의 깊이+1을 append한다 --> depth.append(depth[parent_idx]+1)
  - LCA 찾기
    1. 두개의 노드를 입력받으면 인덱스번호를 info_name[노드이름]으로 찾는다.
    2. index_1과 index_2의 깊이를 비교하고 index_2의 깊이가 낮으면 index_2의 깊이를 더 깊게 한다 (깊이 맞추기에서 index_2만 조정하기 위함)
      - index_1, index_2 = index_2, index_1
    3. while로 index_1과 index_2의 깊이를 맞춘다
      - index_1보다 index_2가 깊으면 -> 부모리스트에서 index_2의 부모를 인덱스를 찾아 index_2에 부모 인덱스를 저장(부모로 한칸 이동)하고 거리값을 +1
    4. 깊이를 맞춘 후 while로 index_1과 index_2가 같은 조상인지 체크하고 아니라면 각각 부모로 한칸 이동하고 거리값 +2 (둘다 부모로 이동하였음)
    5. 최종 거리값을 return하면 두 노드의 같은 조상까지의 거리를 알 수 있음.